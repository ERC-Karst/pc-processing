#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
File (Python):  'to_dxf.py'
author:         Tanguy Racine
date:           2025

Wrapper translating ASCII format centrelines to DXF
"""

import ezdxf
import numpy as np
from os import path

## DXF output functions, written by Otfried Cheong. 
def writeDXF(
    fname: str,
    points_list: list[list[np.ndarray]],
    color: int = ezdxf.colors.GREEN
) -> None:
    
    """ A convenience function used to write a centreline generated by cloud contraction
    to interoperable DXF format. 

        ----------
        arguments:

            fname -> str : the filename
            points_list -> list :
            segs_list -> list : 
            color: str defaults to ezdxf.colors.GREEN

        ----------
        
        returns :
            None

    """

    # build a list of segments along each path for for the path list. 
    segs_list = [[(path[i], path[i + 1]) for i in range(len(path) - 1)] for path in points_list]

    doc = ezdxf.new()
    doc.layers.add("points")
    doc.layers.add("segments")
    msp = doc.modelspace()

    c = 0

    for points, segs in zip(points_list, segs_list):
   
        for p in points:
            q = (p[0],  p[1],  p[2])  # scale to meters
            e = msp.add_point(q, dxfattribs={"layer": "points"})
            e.dxf.color = color
        for p1, p2 in segs:
            q1 = (p1[0],  p1[1],  p1[2])  # scale to meters
            q2 = (p2[0],  p2[1],  p2[2])
            e = msp.add_polyline3d([q1, q2], dxfattribs={"layer": "segments"})
            e.dxf.color = ezdxf.colors.RED
        
        c+=1
    # save the file
    doc.saveas(fname)


def to_DXF(filepath)-> None:
    """
    A convenience function to convert the ASCII centreline files to
    DXF format, wrapping around the writeDXF utility. 

        ----------
        arguments:

            filepath -> str : the path to a specific cave passage directory.

        ----------
        
        returns :
            None
    
    """

    cave, passage = filepath.split(path.sep)[-2:]

    nodes_fp = path.join(filepath, "centreline", f"{cave}_{passage}_nodes_from_LBC.txt")
    branch_fp = path.join(filepath, "centreline", f"{cave}_{passage}_branches_from_LBC.txt")
    edges_fp = path.join(filepath, "centreline", f"{cave}_{passage}_links_from_LBC.txt")

    # for each branch have a different DXF colour / file?
    
    nodes = np.loadtxt(nodes_fp)
    edges = np.loadtxt(edges_fp).astype(int)
    branches = np.loadtxt(branch_fp).astype(int)

    # list the edge tuples for each branch.
    edges_list =[branches[branches[:, 0]==branch][:,1] for branch in np.unique(branches[:,0])]

    # a path is a set of start and end coordinates corresponding to each edge segments.
    path_list = [nodes[edges[edge_list][:, 0]] for edge_list in edges_list]
    
    # set up the output path for centreline in DXF format.
    centreline_filepath = path.join(filepath, "centreline", f"{cave}_{passage}.dxf")

    # call the writeDXF utility function on the list of paths.
    writeDXF(centreline_filepath, path_list, color = ezdxf.colors.GREEN )